#include <iostream>
#include <string>
#include <fstream>
#include <sstream>
#include <vector>
#include <google/protobuf/util/json_util.h>

#include "lc.pb.h"
#include "log.pb.h"
#include "log_result.pb.h"

using namespace pb;
using namespace std;

unsigned char test_buf[] = {
// 0x0A, 0x03, 0x32, 0x2E, 0x30, 0x1A, 0xF9, 0x01, 0x0A, 0x27, 0x2F, 0x74, 0x6D, 0x70, 0x2F, 0x33,
// 0x36, 0x32, 0x36, 0x33, 0x32, 0x31, 0x35, 0x33, 0x33, 0x5F, 0x32, 0x39, 0x5F, 0x74, 0x72, 0x69,
// 0x70, 0x5F, 0x32, 0x32, 0x30, 0x32, 0x32, 0x35, 0x31, 0x32, 0x34, 0x37, 0x35, 0x36, 0x2E, 0x64,
// 0x62, 0x12, 0x15, 0x08, 0xFD, 0x8C, 0x95, 0xC1, 0x0D, 0x10, 0xFD, 0x8C, 0x95, 0xC1, 0x0D, 0x1A,
// 0x07, 0x75, 0x73, 0x6B, 0x30, 0x34, 0x78, 0x78, 0x1A, 0x04, 0x6E, 0x6F, 0x6E, 0x65, 0x22, 0x0B,
// 0x70, 0x62, 0x2E, 0x52, 0x69, 0x64, 0x65, 0x73, 0x4C, 0x6F, 0x67, 0x32, 0x9D, 0x01, 0x0A, 0x10,
// 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x42, 0x43, 0x30, 0x32, 0x45, 0x33, 0x39, 0x39,
// 0x12, 0x02, 0x43, 0x34, 0x18, 0xE7, 0x07, 0x22, 0x01, 0x20, 0x28, 0x01, 0x30, 0x01, 0x40, 0x05,
// 0x48, 0x97, 0x96, 0xED, 0x02, 0x52, 0x07, 0x35, 0x39, 0x38, 0x32, 0x39, 0x39, 0x39, 0x5A, 0x02,
// 0x36, 0x30, 0x60, 0x01, 0x68, 0xFD, 0x8C, 0x95, 0xC1, 0x0D, 0x72, 0x04, 0x30, 0x30, 0x30, 0x30,
// 0x78, 0xE7, 0x07, 0x80, 0x01, 0x19, 0x88, 0x01, 0x02, 0x90, 0x01, 0xE6, 0x0F, 0x98, 0x01, 0x0C,
// 0xA0, 0x01, 0x2F, 0xA8, 0x01, 0x38, 0xB0, 0x01, 0x01, 0xB8, 0x01, 0x19, 0xC0, 0x01, 0x02, 0xC8,
// 0x01, 0xE6, 0x0F, 0xD0, 0x01, 0x0C, 0xD8, 0x01, 0x2F, 0xE0, 0x01, 0x38, 0xE8, 0x01, 0x01, 0xF0,
// 0x01, 0x02, 0xF8, 0x01, 0x01, 0x88, 0x02, 0xF5, 0x15, 0x90, 0x02, 0x06, 0x98, 0x02, 0xEB, 0x03,
// 0xA0, 0x02, 0x01, 0xA8, 0x02, 0x1D, 0xB8, 0x02, 0xB4, 0xB0, 0x89, 0x93, 0x09, 0xC0, 0x02, 0xFD,
// 0x8C, 0x95, 0xC1, 0x0D, 0xF0, 0x02, 0x8B, 0x92, 0xC5, 0xC5, 0x01, 0x3A, 0x04, 0x73, 0x69, 0x67,
// 0x6E, 0x22, 0x17, 0x32, 0x30, 0x32, 0x32, 0x2D, 0x30, 0x32, 0x2D, 0x32, 0x35, 0x20, 0x31, 0x32,
// 0x3A, 0x34, 0x37, 0x3A, 0x35, 0x36, 0x2E, 0x36, 0x31, 0x31};
0x0A, 0x03, 0x32, 0x2E, 0x30, 0x1A, 0xA2, 0x01, 0x0A, 0x21, 0x33, 0x36, 0x32, 0x36, 0x33, 0x32,  
0x31, 0x35, 0x33, 0x33, 0x5F, 0x35, 0x33, 0x30, 0x39, 0x35, 0x5F, 0x73, 0x79, 0x73, 0x5F, 0x32,  
0x32, 0x30, 0x33, 0x30, 0x31, 0x31, 0x33, 0x33, 0x33, 0x31, 0x31, 0x12, 0x15, 0x08, 0xFD, 0x8C,  
0x95, 0xC1, 0x0D, 0x10, 0xFD, 0x8C, 0x95, 0xC1, 0x0D, 0x1A, 0x07, 0x75, 0x73, 0x6B, 0x30, 0x34,  
0x78, 0x78, 0x20, 0x04, 0x32, 0x3A, 0x08, 0xE7, 0x9E, 0x03, 0x10, 0xFD, 0x8C, 0x95, 0xC1, 0x0D,
0x1A, 0x02, 0x45, 0x45, 0x20, 0x01, 0x28, 0x03, 0x30, 0xE6, 0x0F, 0x38, 0x0D, 0x40, 0x21, 0x48,  
0x0B, 0x70, 0xE7, 0x07, 0x9A, 0x01, 0x03, 0x30, 0x2E, 0x30, 0xA2, 0x01, 0x03, 0x30, 0x2E, 0x30,  
0xB0, 0x01, 0xF1, 0xC0, 0xE5, 0xD9, 0x0F, 0xF2, 0x01, 0x06, 0x32, 0x2E, 0x31, 0x36, 0x62, 0x31,  
0x42, 0x28, 0x39, 0x64, 0x61, 0x38, 0x64, 0x61, 0x66, 0x35, 0x35, 0x61, 0x31, 0x61, 0x65, 0x39,
0x30, 0x32, 0x37, 0x30, 0x65, 0x61, 0x35, 0x65, 0x30, 0x61, 0x38, 0x61, 0x37, 0x61, 0x32, 0x37,  
0x38, 0x61, 0x63, 0x30, 0x32, 0x33, 0x36, 0x62, 0x63, 0x35, 0x22, 0x17, 0x32, 0x30, 0x32, 0x32,  
0x2D, 0x30, 0x33, 0x2D, 0x30, 0x31, 0x20, 0x31, 0x33, 0x3A, 0x33, 0x33, 0x3A, 0x31, 0x31, 0x2E,  
0x37, 0x31, 0x33};

void test_buf_to_file()
{
	std::fstream output("test.proto.bin", std::ios::out | std::ios::trunc | std::ios::binary);

	output.write(reinterpret_cast<char*>(test_buf), sizeof test_buf);

	output.flush();
	output.close();
}


void parse_message(const pb::Message &msg)
{
	if(msg.type() == pb::SELL_LOG){
		SellLog sells;

		if( !sells.ParseFromString(msg.data()) ){
			cerr << "Failed to ParseFromString SellLog" << endl;
			return;
		}

		cout << "SellLog content:" << endl;
		cout << sells.DebugString() << endl;
	}
	else if(msg.type() == pb::RIDES_LOG){

		RidesLog rides;

		if( !rides.ParseFromString(msg.data()) ){
			cerr << "Failed to ParseFromString RidesLog" << endl;
			return;
		}

		cout << "RidesLog content:" << endl;
		cout << rides.DebugString() << endl;

	}
	else if(msg.type() == pb::VIEW_LOG){
		ViewLog view;

		if( !view.ParseFromString(msg.data()) ){
			cerr << "Failed to ParseFromString ViewLog" << endl;
			return;
		}

		cout << "ViewLog content:" << endl;
		cout << view.DebugString() << endl;
	}
	else if(msg.type() == pb::SYS_LOG){
		SysEventsLog sys;

		if( !sys.ParseFromString(msg.data()) ){
			cerr << "Failed to ParseFromString SysEventsLog" << endl;
			return;
		}

		cout << "SysEventsLog content:" << endl;
		cout << sys.DebugString() << endl;
	}
	else if(msg.type() == pb::LOG_RESULT){
		LogResult log_res;

		if( !log_res.ParseFromString(msg.data()) ){
			cerr << "Failed to ParseFromString LogResult" << endl;
			return;
		}

		cout << "LogResult content:" << endl;
		cout << log_res.DebugString() << endl;
	}
}

void parse_message_from_file(const std::string &file_name)
{
	Message msg;

	fstream input(file_name, ios::in | ios::binary);
	if( !input.is_open() ){
		cerr << "Failed to open " << file_name << endl;
		return;
	}

	if( !msg.ParseFromIstream(&input) ){
		cerr << "File parse error" << endl;
		return;
	}

	string s;
	google::protobuf::util::MessageToJsonString(msg, &s);

	cout << "Input message as JSON: " << s << "\n" << endl;

	parse_message(msg);
}

void parse_package_from_file(const std::string &file_name)
{
	Package pckg;

	fstream input(file_name, ios::in | ios::binary);
	if( !input.is_open() ){
		cerr << "Failed to open " << file_name << endl;
		return;
	}

	if( !pckg.ParseFromIstream(&input) ){
		cerr << "File parse error" << endl;
		return;
	}

	string s;
	google::protobuf::util::MessageToJsonString(pckg, &s);

	cout << "Input package as JSON: " << s << "\n" << endl;

	cout << "Input package debug:\n" << pckg.DebugString() << endl;

	for(int i = 0; i < pckg.messages_size(); ++i){

		const auto& msg = pckg.messages(i);
		parse_message(msg);
	}
}

int main(int argc, char* argv[])
{
	using namespace pb;
	using namespace std;

	if(argc <= 1){
		return 1;
	}

	string param = argv[1];

	if(param == "-tb"){
		test_buf_to_file();
	}
	else if(param == "-pm"){
		parse_message_from_file(argv[2]);
	}
	else if(param == "-pp"){
		parse_package_from_file(argv[2]);
	}

	return 0;
}





int lib_test ()
{
	using namespace pb;
	using namespace std;

	GOOGLE_PROTOBUF_VERIFY_VERSION;

	Package pckg;
	pckg.set_protocol_ver("2.0");
	DevInfo *pdev_info = pckg.mutable_devinfo();
	pdev_info->set_psu(232);
	pdev_info->set_sys_id(1001);
	pdev_info->set_type("SUV");
	Message *pmsg = pckg.add_messages();
	pmsg->set_name("psu_tyne_cnt_2120120");
	pmsg->set_encrypted(pb::NONE);
	pmsg->set_type(pb::SYS_LOG);

	pmsg->mutable_devinfo()->set_psu(444);

	char buf[] = {'T', 'E', 'S', 'T', ' ', 'd', 'a', 't', 'a'};

	pmsg->set_data(static_cast<void*>(buf), sizeof buf);
	pmsg->set_signature("signature");

	pckg.set_current_time("10:1201203103");


	fstream output("test.binary", ios::out | ios::trunc | ios::binary);
	if( !output.is_open() ){
		cerr << "Failed to open output file" << endl;
		return 1;
	}

	if( !pckg.SerializeToOstream(&output) ){
		cerr << "Failed to write proto binary" << endl;
		return 1;
	}

	output.close();

	fstream input("test.binary", ios::in | ios::binary | ios::ate);
	if( !input.is_open() ){
		cerr << "Failed to open test file" << endl;
		return 1;
	}

	size_t fsize = input.tellg();
	cout << "files size: " << fsize << endl;
	input.seekg(0, ios::beg);
	// unique_ptr<char[]> bytes (new char[fsize]);

	vector<char> vec(fsize);
	char *bytes = &vec[0];

	if( !input.read(bytes, fsize) ){
		cerr << "Failed to read test file" << endl;
		return 1;
	}

	size_t bytes_read = input.gcount(); // сколько реально прочитано
	cout << "bytes read: " << bytes_read << endl;

	Package in_package;
	if( !in_package.ParseFromArray(bytes, bytes_read) ){
		cerr << "Failed to ParseFromArray in_package" << endl;
		return 1;
	}

	string s;
	google::protobuf::util::MessageToJsonString(in_package, &s);

	cout << "in_package:" << endl;
	cout << s << endl;

	Package test_package;
	if( !test_package.ParseFromArray(test_buf, sizeof test_buf) ){
		cerr << "Failed to ParseFromArray test_package" << endl;
		return 1;
	}

	string s_test;
	google::protobuf::util::MessageToJsonString(test_package, &s_test);

	cout << "test_package:" << endl;
	cout << s_test << endl;


	for(int i = 0; i < test_package.messages_size(); ++i){

		// const auto &msg = test_package.messages(i);
		// const auto &msg_type = msg.type();

	}


	// cout << "Package.current_time: " << in_package.current_time() << endl;
	// cout << "Package.protocol_ver: " << in_package.protocol_ver() << endl;


	// Optional:  Delete all global objects allocated by libprotobuf.
	google::protobuf::ShutdownProtobufLibrary();
	return 0;
}
